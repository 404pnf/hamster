* Make List#sort/#sort_by efficient :)
* Make Set#sort/#sort_by efficient :)
* Add List #count, #last, #nub, #each_slice, #flatten, #nub (#uniq), #product, #fill, #sample, #index (#find_index), #init, #slice, #each_slice (#chunks or perhaps #slices ????), #insert, #insert_by, #to_set
* Add Set #find (#detect), #count, #partition, #one?, #sort, #sort_by, #max(imum), #min(imum), #cycle, #product, #sample, #clear
* Add Hash #find (#detect), #count, #partition, #one?, #sort, #sort_by, #max(imum), #min(imum), #cycle, #clear
* Implement Set#union aliased as #| and #+
* Implement Set#intersection aliased as #&
* Implement Set#difference aliased as #-
* Implement Set#subtract
* Implement Set#subset?
* Implement Set#superset?
* Implement Set#^ as equivalent to ((set | enum) - (set & enum))
* Implement Hash#merge
* Work out what we can extract into common "Enumerable-like" code.
* Independently test list methods on intervals.
* Make Set and Hash lazy
* Test laziness of List methods that don't take a block.
* Generate spec docs
* Laziness tests can be simplified
* Add more tests for each method on streams and intervals
* Add missing immutability tests to Set
* Add missing immutability tests to Hash
* Add missing immutability tests to Stack
* Re-write Trie test-first (it was only a spike)
* Allow Trie to efficiently add multiple pairs in one go
* Implement Vector (using a Trie and integer keys?)
* Allow drop_while, etc. to be lazy using a stream (or something like that)
* Factor out the large list stack test stuff.
* Some of the stack-depth tests are not failing (when the might otherwise) due to the laziness of the implementation. d'oh!
* Consider creating a stream that takes another list element rather than needing to have the head? the only problem with this is it won't allow the original to be garbage collected. Hmmm
* Consider making List#join more efficient than simply calling to_a.join!
