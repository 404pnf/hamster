= Hamster

Hamster started out as an implementation of Hash Array Mapped Hashs (HAMT) for Ruby (see http://lamp.epfl.ch/papers/idealhashtrees.pdf) and has since expanded to include implementations of other Persistent Data Structures (see http://en.wikipedia.org/wiki/Persistent_data_structure) such as Sets, Lists, Stacks, etc.

== Huh?

Persistent data structures have a really neat property: very efficient copy-on-write operations. That allows you to create immutable data-structures that only need copying when something changes. For example:

  require 'hamster'

  hash = Hamster::Hash[]

  hash.put("Name", "Simon")
  hash.has_key?("Name")     # => false
  hash.get("Name")          # => nil

== Double Huh? That's not much use!

Whoops! Remember, each call to <tt>#put</tt> creates an efficient copy containing the modifications, leaving the original unmodified. So, unlike Ruby's built-in <tt>Hash</tt> all Hamster classes follow Command-Query-Seperation (see http://martinfowler.com/bliki/CommandQuerySeparation.html) and return the modified copy of themselves after any mutating operation. Let's try that again:

  require 'hamster'

  original = Hamster::Hash[]
  copy = hash.put("Name", "Simon")

  original.get("Name")             # => nil
  copy.get("Name")                 # => "Simon"

The same goes for <tt>#remove</tt>:

  require 'hamster'

  original = Hamster::Hash[]
  original = hash.put("Name", "Simon")
  copy = hash.remove("Name")

  original.get("Name")  # => Simon
  copy.get("Name")      # => nil

== Oh, I get it. Cool. But I still don't understand why I should care?

As mentioned earlier, persistent data structures perform a copy whenever they are modified meaning there is never any chance that two threads could be modifying the same instance at any one time. And, because they are very efficient copies, you don't need to worry about using up gobs of heap space in the process.

== OK, that sounds mildly interesting. What's the downside--there's always a downside?

There's a potential performance hit when compared with MRI's built-in, native, hand-crafted C-code implementation of <tt>Hash</tt>. For example:

  require 'hamster'

  hash = Hamster::Hash[]
  (1..10000).each { |i| hash = hash.put(i, i) }  # => 0.05s
  (1..10000).each { |i| hash.get(i) }  # => 0.008s

versus

  hash = {}
  (1..10000).each { |i| hash[i] = i }  # => 0.004s
  (1..10000).each { |i| hash[i] }  # => 0.001s

== That seems pretty bad?

Well, yes and no. The previous comparison wasn't really fair. Sure, if all you want to do is replace your existing uses of <tt>Hash</tt> in single-threaded environments then don't even bother. However, if you need something that can be used efficiently in concurrent environments where multiple threads are accessing--reading AND writing--the contents things get much better.

== Do you have a better example?

A more realistic comparison might look like:

  require 'hamster'

  hash = Hamster::Hash[]
  (1..10000).each { |i| hash = hash.put(i, i) }  # => 0.05s
  (1..10000).each { |i| hash.get(i) }  # => 0.008s

versus

  hash = {}
  (1..10000).each { |i|
    hash = hash.dup
    hash[i] = i
  } # => 19.8s

  (1..10000).each { |i| hash[i] }  # => 0.001s

Impressive huh? What's even better is--or worse depending on your perspective--is that after all that, the native <tt>Hash</tt> version still isn't thread-safe and still requires some synchronisation around it slowing it down even further!

The <tt>Hamster::Hash</tt> version on the other hand was unchanged from the original whilst remaining inherently thread-safe, and 3 orders of magnitude faster!

== Sure, but as you say, you still need synchronisation so why bother with the copying?

Well, I could show you one but I'd have to re-write--or at least wrap--most <tt>Hash</tt> methods to make it generic, or at least write some application-specific code that synchronised using a <tt>Mutex</tt> and ... well ... it's hard, I always make mistakes, I always end up with weird edge cases and race conditions so, I'll leave that as an exercise for you :)

== And that, my friends, is why you might want to use one :)
