= Hamster

An implementation of Hash Array Mapped Tries (HAMT) for Ruby (see http://lamp.epfl.ch/papers/idealhashtrees.pdf).

Why do you care?

HAMTs are a Persistent Data Structure (see http://en.wikipedia.org/wiki/Persistent_data_structure) making it really easy to build hash tables with one neat property: very efficient copy-on-write operations. For example:

	trie = Hamster::Trie.new

	trie.put("Name", "Simon")
	trie.has_key?("Name")     # => false
	trie.get("Name")          # => nil

Huh? That's not much use!

Remember, each instance of a trie is immutable. #put creates an efficient copy containing the modifications. So, let's try that again:

	trie = Hamster::Trie.new

	trie = trie.put("Name", "Simon")
	trie.has_key?("Name")            # => true
	trie.get("Name")                 # => "Simon"

The same goes for remove:

	trie = Hamster::Trie.new

	trie = trie.put("Name", "Simon")
	trie = trie.put("Gender", "Male")
	trie = trie.remove("Name")
	trie.get("Name")    # => nil
	trie.get("Gender")  # => "Male"

So tell me again why I care?

As mentioned earlier, HAMTs perform a copy whenever they are modified meaning there is never any chance that two threads could be modifying the same instance at any one time. And, because they are very efficient copies, you don't need to worry about using up gobs of heap space in the process.

Thats nice but I don't really have multi-threading issues.

OK, how about transactional memory:

	Need an example

So what's the downside?

The downside is that because the implementation is pure Ruby, MRI's built-in, native, hand-crafted C-code implementation of Hash is 10-times faster!
