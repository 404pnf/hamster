= Hamster

An implementation of Hash Array Mapped Hashs (HAMT) for Ruby (see http://lamp.epfl.ch/papers/idealhashtrees.pdf).

Why do you care?

HAMTs are a Persistent Data Structure (see http://en.wikipedia.org/wiki/Persistent_data_structure) making it really easy to build hash tables with one neat property: very efficient copy-on-write operations. For example:

	hash = Hamster::Hash.new

	hash.put("Name", "Simon")
	hash.has_key?("Name")     # => false
	hash.get("Name")          # => nil

Huh? That's not much use!

Remember, each instance is immutable--#put creates an efficient copy containing the modifications. So, let's try that again:

	hash = Hamster::Hash.new

	hash = hash.put("Name", "Simon")
	hash.has_key?("Name")            # => true
	hash.get("Name")                 # => "Simon"

The same goes for remove:

	hash = Hamster::Hash.new

	hash = hash.put("Name", "Simon")
	hash = hash.put("Gender", "Male")
	hash = hash.remove("Name")
	hash.get("Name")    # => nil
	hash.get("Gender")  # => "Male"

So tell me again why I care?

As mentioned earlier, HAMTs perform a copy whenever they are modified meaning there is never any chance that two threads could be modifying the same instance at any one time. And, because they are very efficient copies, you don't need to worry about using up gobs of heap space in the process.

Thats nice but I don't really have multi-threading issues.

OK, how about transactional memory:

	Need an example

So what's the downside?

The downside is that because the implementation is pure Ruby, MRI's built-in, native, hand-crafted C-code implementation of Hash is 10-times faster!
