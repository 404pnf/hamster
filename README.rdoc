= Hamster

Hash Array Mapped Tries (HAMT) for Ruby (see http://lamp.epfl.ch/papers/idealhashtrees.pdf).

Why do you care?

HAMTs are hash tables with one really neat property: their structure enables you to perform very efficient copy-on-write operations. For example:

	trie = Hamster::Trie.new

	trie.put("Name", "Simon")
	trie.get("Name")          # => nil

Huh? That's not much use!

Remember, each instance of a trie is immutable. #put creates an efficient copy containing the modifications. So, let's try that again:

	trie = Hamster::Trie.new

	trie = trie.put("Name", "Simon")
	trie.get("Name")                 # => "Simon"

The same goes for remove:

	trie = Hamster::Trie.new

	trie = trie.put("Name", "Simon")
	trie = trie.put("Gender", "Male")
	trie = trie.remove("Name")
	trie.get("Name")    # => nil
	trie.get("Gender")  # => "Male"

So tell me again why I care?

As mentioned earlier, HAMTs perform a copy whenever they are modified meaning there is never any chance that two threads could be modifying the same instance at any one time. And, because they are very efficient copies, you don't need to worry about using up gobs of heap space in the process.

Thats nice but I don't really have mutli-threading issues.

OK, how about transactional memory:

	Need an example

So what's the downside?

The downside is that because the implementation is pure Ruby, MRI's built-in, native, hand-crafted C-code implementation of Hash is 10-times faster!
