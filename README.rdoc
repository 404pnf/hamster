= Hamster

Hamster started out as an implementation of Hash Array Mapped Hashs (HAMT) for Ruby (see http://lamp.epfl.ch/papers/idealhashtrees.pdf) and has since been expanded to other Persistent Data Structures (see http://en.wikipedia.org/wiki/Persistent_data_structure) for Sets, Lists, Stacks, etc.

== Why do you care?

Persistent data structures have a really neat property: very efficient copy-on-write operations. For example:

	require 'hamster'

	hash = Hamster::Hash.new

	hash.put("Name", "Simon")
	hash.has_key?("Name")     # => false
	hash.get("Name")          # => nil

== Huh? That's not much use!

Remember, each call to #put creates an efficient copy containing the modifications, leaving the original unmodified. So, let's try that again:

	require 'hamster'

	hash = Hamster::Hash.new

	hash = hash.put("Name", "Simon")
	hash.has_key?("Name")            # => true
	hash.get("Name")                 # => "Simon"

The same goes for #remove:

	require 'hamster'

	hash = Hamster::Hash.new

	hash = hash.put("Name", "Simon")
	hash = hash.put("Gender", "Male")
	hash = hash.remove("Name")
	hash.get("Name")    # => nil
	hash.get("Gender")  # => "Male"

== So tell me again why I care?

As mentioned earlier, persistent data structures perform a copy whenever they are modified meaning there is never any chance that two threads could be modifying the same instance at any one time. And, because they are very efficient copies, you don't need to worry about using up gobs of heap space in the process.

== So what's the downside?

There's a potential performance hit when compared with MRI's built-in, native, hand-crafted C-code implementation of <tt>Hash</tt>. For example:

	require 'hamster'

	hash = Hamster::Hash.new
	(1..10000).each { |i| hash = hash.put(i, i) }	# => 0.05s
	(1..10000).each { |i| hash.get(i) }	# => 0.008s

versus

	hash = {}
	(1..10000).each { |i| hash[i] = i }  # => 0.004s
	(1..10000).each { |i| hash[i] }  # => 0.001s

== That seems pretty bad?

Well, yes and no. The previous comparison wasn't really fair. Sure, if all you want to do is replace your existing uses of <tt>Hash</tt> in single-threaded environments then don't even bother. However, if you need something that can be used efficiently in concurrent environments where multiple threads are accessing the contents--both read AND writing--a more realistic comparison might look like:

	require 'hamster'

	hash = Hamster::Hash.new
	(1..10000).each { |i| hash = hash.put(i, i) }	# => 0.05s
	(1..10000).each { |i| hash.get(i) }	# => 0.008s

versus

	hash = {}
	(1..10000).each { |i|
		hash = hash.dup
		hash[i] = i
	} # => 19.8s

	(1..10000).each { |i| hash[i] }  # => 0.001s

Impressive huh? What's even better is--or worse depending on your perspective--is that after all that, the native <tt>Hash</tt> version still isn't thread-safe and still requires some synchronisation around it slowing it down even further!

The <tt>Hamster::Hash</tt> version on the other hand was unchanged from the original whilst remaining inherently thread-safe, and 3 orders of magnitude faster!

And that, my friends, is why you might want to use one :)
